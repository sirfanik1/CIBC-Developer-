class Graph():
    def __init__(self, vertices, edges):
        self.vertices = set(vertices)
        # initialize a set of incoming and outcoming vertices for each vertex
        self.incoming = {vertex: set() for vertex in self.vertices}
        self.outcoming = {vertex: set() for vertex in self.vertices}
        
        # fill incoming and outcoming vertex for each edge
        for (vertex_out, vertex_in) in edges:
            self.incoming[vertex_in].add(vertex_out)
            self.outcoming[vertex_out].add(vertex_in)
        
    def toposort(self):
        sorted_vertices = []
        # start vertices is the vertices with no edges incoming (no dependencies)
        start_vertices = set(vertex for vertex in self.incoming if len(self.incoming[vertex]) == 0)
        # while there is still vertices with no dependencies or satistied (resolved)
        while len(start_vertices) > 0:
            # extract vertex with resolved dependencies
            vertex = start_vertices.pop()
            sorted_vertices.append(vertex)
            # resolve dependency on current vertex, i.e. remove all dep. edges from this vertex to any other
            for vertex_in in list(self.outcoming[vertex]):
                self.incoming[vertex_in].remove(vertex)
                self.outcoming[vertex].remove(vertex_in)
                # if there is no incoming edges for that vertex, add it to set of start vertices
                if len(self.incoming[vertex_in]) == 0:
                    start_vertices.add(vertex_in)
        # if there is still edges in a graph, then we have a cycle, cant resolve
        # otherwise return sorted vertices
        if any(len(edges) > 0 for edges in self.outcoming.values()):
            return "error"
        else:
            return sorted_vertices

#projects = [c for c in 'abcdf']
#dependencies = [('a', 'd'), ('f', 'b'), ('b', 'd'), ('f', 'a'), ('d', 'c')]

"""
a b c d e f
(a, d), (f, b), (b, d), (f, a), (d, c)

"""

if __name__ == "__main__":
    ### read projects and depentencies
    projects = input("projects: ").split()
    dependencies = list(map(lambda x: tuple(x.split(", ")), input("dependencies: ")[1:-1].split("), (")))
    graph = Graph(projects, dependencies)
    resolved = graph.toposort()
    print(resolved)
